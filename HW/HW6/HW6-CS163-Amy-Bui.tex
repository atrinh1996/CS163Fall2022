% -*- LaTeX -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Template for scribing COMP163 - Computational Geometry 
%
% Spring, 2004
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%**start of header 

\documentclass [12pt]{article}
\usepackage{epsfig}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[color, leftbars]{changebar}

\usepackage{caption}
\usepackage{subcaption}


\usepackage{color}
\definecolor{light-gray}{gray}{0.97} % shade of grey
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xcolor}
%% https://tex.stackexchange.com/questions/401750/quick-and-short-command-for-coloring-one-word
\newcommand\shorthandon{\catcode`@=\active \catcode`^=\active \catcode`*=\active }
\newcommand\shorthandoff{\catcode`@=12 \catcode`^=7 \catcode`*=12 }
\shorthandon
\def@#1@{\textcolor{red}{#1}}%
\def^#1^{\textcolor{blue}{#1}}%
\def*#1{\string#1}
\shorthandoff
%% useage: \textcolor{red}{text here}
% \shorthandon
% This is a @test@ of the ^emergency^ bro*@dcast system.
% \shorthandoff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\setlength{\textwidth}{6.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{-0.5in}

\setlength{\parindent}{0pt}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proof}[theorem]{Proof}

\newlength{\toppush}
\setlength{\toppush}{2\headheight}
\addtolength{\toppush}{\headsep}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue, % was previously black
    filecolor=magenta,
    urlcolor=blue,
    pdftitle={Template}
}
\urlstyle{same}

%\doheading{2}{title}{Last Revised: January, 2004}
%\htitle{title}

\def\subjnum{Comp 163}
\def\subjname{Computational Geometry}

\def\doheading#1#2#3{\vfill\eject\vspace*{-\toppush}%
  \vbox{\hbox to\textwidth{{\bf} \subjnum: \subjname \hfil Amy Bui}%
    \hbox to\textwidth{{\bf} Tufts University, Fall 2022 \hfil#3\strut}%
    \hrule}}

\newcommand{\htitle}[1]{\vspace*{3.25ex plus 1ex minus .2ex}%
\begin{center}
{\large\bf #1}
\end{center}} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\doheading{2}{title}{HW 6} 
% \htitle{Homework 1}
% \bigskip 
% \bigskip 
%%%%%%%%%% begin text after this line %%%%%%%%%%%%%%

%%
%% treap, interval, segment trees, range tree
%% range search
%%

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \section{Data Structures}
    \label{sec:one}

        \begin{enumerate}[label=(\alph*)]
            \item We can use an segment tree as the primary data structure $\mathcal{T}$ to store horizontal interval segments and their $y$-positions. Using the segment endpoints $x$-coordinates, the primary tree can order the segments by the $x$-ordered intervals. This way, we can query which segments contain query point $q_x$ in $O(\log^2 n + k)$ time, where $k$ is the number of segments containing $q_x$. But we need to narrow the answer to those segments whose $y$-positions are in the range of $[\ell_y, h_y]$. So in addition to the primary data structure, the associated data structure can be a list that contain the $y$-position of a segment; so each node contains the segment it covers and a list of those segments' $y$-positions. Additional segments that the vertical query segment $q$ may pierce can be found by traversing the segment tree as described in the book (p. 234). 
            
            The time to build this augmented tree is the same as the preprocessing time for building a regular segment tree in $O(n\log n)$ time, where $n$ is the number of segments and the depth is $O(\log n)$. I don't think this tree needs another tree as the associated data structure at each node, since we only need the $y$-positions of segments that contain a point with $x$-coord $q_x$. 

            Likewise, storage is $O(n\log n)$ for $n$ segments and a tree of depth $O(\log n)$. The addition of the $y$-position list at each node is only for those nodes that contain a segment interval, and there is only every at most $O(n)$ additional space for the $y$-position for the entire tree, not each not. So the space is $O(n\log n)$, rather than $O(n^2 \log n)$.
            
            % \begin{itemize}
            %     \item reduce problem to 1D, where we make an x-axis interval tree, and a y-axis interval tree (When we collapse the dimension.)
            %     \item Diane/Stephanie suggests segment tree.
            %     \item Describe the augmented free, and discuss the preprocessing (build), query time, and space complexities
            %     \item Problem example: multiple horizontal interval segments in $S$. Given a vertical, report the number of interval segments it intersects. With a segment tree, the path down to a leaf will give you the segments the vertical hits. Requires to know the y-coord of the horizintal to remove extra nodes that the vertical doesn't actually cross. Query is $O(\log^2 n)$ (log for the primary tree path, and log for the secondary tree).
            % \end{itemize}
            
            \item As the problem suggests, we can organize the points in an interval that also uses two treaps as the associated data structures. The primary tree $\mathcal{T}$ is built such that nodes are organized by the $x$-values of the points. So we can traverse down the tree until we meet a median $x$ value stored in a node that is contained by the ractangluar query's $x$ interval. Once there, we traverse down each subtree to find the next nodes just within the query's $x$-range (i.e. the leftmost node in the left subtree and the right most node in the right subtree). Each node can have two treaps\footnote{Jake and Diane discussed this augmentation for the primary tree that works to find points in two rectangular intervals} built from the points of the enture subtree of the current node, as a treap can report the points in an open rectangluar query range in $O(\log n + k)$ time (lemma 10.8, page 230) for $k$ solution points; one $S_L$ treap that can report the left closed interval of points the query, and one $S_R$ treap that can report the right closed interval of the query, where the final solution is the points contained in both query sets.
            
            The storage for one normal BBST is $O(n)$; each node also stores treaps based on the node's subtrees' point, so with each level deeper into the tree, the associated data structure becomes smaller because the tree is balanced; but the total storage is still $O(n^2)$ because each level of the tree stores a total of $O(n)$ additional space for all associated treap on each level of the primary tree. Likewise, preprocessing would take $O(n^2 \log^2 n)$ time because there are $n$ points for the primary tree of depth $O(\log n)$, and each node's treaps take $O(n\log n)$ to build. Query would take $O({\log n + A})$ where $A$ is the number of solutions in the query range: it takes $O(\log n)$ time to find the median $x$ in the node of the primary tree and the target nodes, and an additional $O({\log n + A})$ for each of the node's two treaps to report the points in the rectangular range. 

            % \begin{itemize}
            %     \item Do a half open query on SL and SR. With the treap, we can stop when we are done 
            %     \item Find the height of the tree that matches the query range for your search
            %     \item (Diane) In a treap, go down to find where you pierce (each $p$ knows where it's median/pierce is), then look in secondary DS. Each node in primary seeps a copy of its SL and SR treap or intervals. Do the  half open interval query on the sub SL and Sub SR
            % \end{itemize}
            
        \end{enumerate}
        
    % \pagebreak
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \section{Boundary of Intersection}
    \label{sec:two}

    \begin{enumerate}[label=(\alph*)]
        \item Given two arbitrary simple polygons of $n$ vertices, we can compute the boundary of the intersection with a vertical line sweep. In addition to stopping at each vertec point, we must also stop at each intersection point in the set, so there are $O(n^2)$ stops. At each stop, we update along the sweep line the faces we passed and update how many polygons the current face covers (0, 1, or 2). For those stopping points that change the count from 0 to 2, 2 to 0, 1 to 2, or 2 to 1, add those points to the solution, as they indicate entering/leaving an intersection region of the two polygons. There is $O(\log n)$ work at each stopping point, so the total runtime is $O(n^2 \log n)$\footnote{Jake went over how to determine this method's runtime in OH.}. Storage remains $O(n)$ if the status DS is updated at each pass, removing points allready processed.
        
        \item We can solve a similar problem with two recilinear polygons with line sweep, as well, where the stopping points are in a segment tree DS ($O(n\log n)$ space) and we only need to stop and process the intersecting regions at each \emph{vertical} line segment in the data structure, rather than stop at every point and intersection point. There are now only $O(n)$ stops, and we process how many polygons the current face covers and report solution points similar to how we did above: report points that make the count go from 0 to 1, 1 to 2, 2 to 1, and 1 to 0 indicate intersection regions for rectilinear polygons. With $O(\log n)$ time processing at each stop, the total runtime is $O(n\log n)$.
    \end{enumerate}
        
    % \pagebreak
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % \section{Draw}
    % \label{sec:three}

    % \begin{enumerate}[label=(\alph*)]
    %     \item 
        
    %     \item 
        
    % \end{enumerate}
        
    % \pagebreak
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{thebibliography}{1}
    \bibitem[1]{officehours}Jake and Diane's office hours.
    \bibitem[2]{berg08}Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars. 2008. Computational Geometry: Algorithms and Applications (3rd ed. ed.). Springer-Verlag TELOS, Santa Clara, CA, USA.
\end{thebibliography}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

