%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Template latex file for a common article class for class notes
% and write ups. Additional Configuration and styling options are 
% commented out. ex. Table of Contents and Title page
% 
% Author: Amy Bui
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{parskip}
\usepackage{tabularx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[color, leftbars]{changebar}
\usepackage{mathrsfs}

% Important Configurations

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reduce margin
%
% \addtolength{\oddsidemargin}{-.85in}
% \addtolength{\evensidemargin}{-.85in}
% \addtolength{\textwidth}{1in}

% \addtolength{\topmargin}{-.85in}
% \addtolength{\textheight}{1in}

% Page format commands:
% Override normal article margins,
% making the margins smaller
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{-0.5in}

\setlength{\parindent}{0pt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Math Symbols
\usepackage{mathtools}
\usepackage{amssymb}
% \usepackage{epsfig}
\usepackage{amsmath,amsthm}
\usepackage{amscd,amsxtra,latexsym}


% add floor and ceiling symbol. Usage: \ceil*{}, \floor*{}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

% multiset \langle ... \rangle
\def\multiset#1#2{\ensuremath{\left(\kern-.3em\left(\genfrac{}{}{0pt}{}{#1}{#2}\right)\kern-.3em\right)}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Code Sample Styling

% use \lstinline! xxx ! or \begin{lstlisting} ... \end{lstlisting}
\usepackage{listings}

\usepackage{color}
\definecolor{light-gray}{gray}{0.97} % shade of grey
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% \begin{lstlisting}[...] ... \end{lstlisting}
\lstset{frame=none,
    language=C++,
    aboveskip=3mm,
    belowskip=3mm,
    stepnumber=1, % set to 0 if you don't like line nums
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=left,
    numberstyle=\color{black},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    backgroundcolor=\color{light-gray},
    breaklines=true,
    breakatwhitespace=false,
    tabsize=2
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{xcolor}
%% https://tex.stackexchange.com/questions/401750/quick-and-short-command-for-coloring-one-word
\newcommand\shorthandon{\catcode`@=\active \catcode`^=\active \catcode`*=\active }
\newcommand\shorthandoff{\catcode`@=12 \catcode`^=7 \catcode`*=12 }
\shorthandon
\def@#1@{\textcolor{red}{#1}}%
\def^#1^{\textcolor{blue}{#1}}%
\def*#1{\string#1}
\shorthandoff
%% useage: \textcolor{red}{text here}
% \shorthandon
% This is a @test@ of the ^emergency^ bro*@dcast system.
% \shorthandoff
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Commands below change page margins (this much space at the titlepage, etc)
\newlength{\toppush}
\setlength{\toppush}{2\headheight}
\addtolength{\toppush}{\headsep}

% Section header Styling
% The commands below change the bold text where it says "Section" into "Question"
% \usepackage{titlesec}
% \titleformat{\section}
% {\normalfont\Large\bfseries}{Question~\thesection:}{1em}{}

% I added this command below to chance "subsections numbers" to be "Question [subsection number]" -AB 1/31/2021
% \titleformat{\subsection}
% {\normalfont\bfseries}{\thesubsection:}{1em}{}

% Page head Styling
% Name and subject of the class
\def\subjnum{Comp 163}          % Class Number
\def\subjname{CompGeo}       % Class Name

% Name of the student, university name and which semester
\def\doheading#1#2#3{\vfill\eject\vspace*{-\toppush}%
  \vbox{\hbox to\textwidth{{\bf} \subjnum: \subjname \hfil Amy Bui}%
    \hbox to\textwidth{{\bf} Tufts University, Fall 2022 \hfil#3\strut}%
    \hrule}}

%Command for the title of the document (Homework 0)
\newcommand{\htitle}[1]{\vspace*{1.25ex plus 1ex minus 0ex}%
\begin{center}
    {\large\bf #1}
\end{center}} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Misc
\usepackage{graphicx} % graphics
\usepackage{enumitem} % listing style (bullet lists)

% below helps with trying to get figures in a row
% \usepackage{caption}
% \usepackage{subcaption}

% hyperlink styling
% use \href{} and \url{}, and colors table of contents links
% use \href{} and \url{}
% \label{sec:name}
% \hyperref[label]{text}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue, % was previously black
    filecolor=magenta,
    urlcolor=blue,
    pdftitle={Template}
}
\urlstyle{same}

% A command for primes (')
\newcommand{\p}%
    {\ensuremath{^{\prime}}}

% a command for double primes ('')
\newcommand{\pp}%
    {\ensuremath{^{\prime \prime}}}

% A command for the Kleene star
\newcommand{\str}%
    {\ensuremath{^{\star}}}

% a command for the double star
\newcommand{\sstr}%
    {\ensuremath{^{\star\star}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Options for title page, use \maketitle in document
% \author{Amy Bui}
% \title{COMP160 - Algorithms: Class Notes and Practice}

\begin{document}
%% create title page
% \title{(g)ROOT \\ Language Reference Manual}
% \author{Samuel Russo \quad Amy Bui \quad Eliza Encherman \\ Zachary Goldstein \quad Nickolas Gravel}
% \date{\today}
% \maketitle

\doheading{2}{title}{Notes}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Table of Contents
    \setcounter{tocdepth}{2}
    \tableofcontents
    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \section{Algorithms: Overview}
    \label{sec:allalgo}

        \begin{center}
            \begin{tabular}{|p{2.5cm}|p{3cm}|p{3cm}|p{2cm}|p{2cm}|p{2.25cm}|}
                \hline
                \hline
                \textbf{TOPIC/type} & \textbf{Name} & \textbf{Best} & \textbf{Average} & \textbf{Worst} & \textbf{Space} \\ 
                \hline
                \hline
                \hyperref[sec:convexhull]{\textbf{Convex Hull}} & & $\Omega(n)$ & & $O(n^4)$ &  \\
                \hline
                incremental & \hyperref[subsec:chn4]{Naive Approach (Triples)} & $\Omega(n^4)$ & $\Theta(n^4)$ & $O(n^4)$ & $O(n)$ \\
                \hline
                incremental & \hyperref[subsec:slowhull]{Slow $\mathcal{CH}$ (Pairs)} & $\Omega(n^3)$ & $\Theta(n^3)$ & $O(n^3)$ & $O(n)$ \\
                \hline
                incremental & \hyperref[subsec:giftwrapping]{Jarvis March(Gift Wrapping)} & $\Omega(n h)$ & $\Theta(n \log n)$ & $O(n^2)$ & $O(n)$ \\
                \hline
                \hyperref[subsec:chinc]{incremental} & \hyperref[subsec:gscan]{Graham Scan} & $\Omega(n \log n)$ & $\Theta(n \log n)$ & $O(n \log n)$ & $O(n)$ \\
                \hline
                D\&C& \hyperref[subsec:quickhull]{Quick Hull} & $\Omega(n\log n)$ & $\Theta(n \log n)$ & $O(n^2)$ & $O(n)$ \\
                \hline
                prune\&search& \hyperref[subsec:ultimatehull]{Marriage before Conquest (Ultimate)} & $\Omega(n \log h)$ & $\Theta(n \log h)$ & $O(n \log h)$ & \\
                \hline
                order decomp & \hyperref[subsec:dynamichull]{Dynamic Convex Hull} (updates) & $\Omega(\log^2 n)$ & $\Theta(\log^2 n)$ & $O(\log^2 n)$ & \\
                \hline
                \hyperref[]{\textbf{Intersecting Points}} & & $\Omega(?)$ & & $O(n^2)$ &  \\
                \hline
                & Naive & $\Omega(n^2)$ & $\Theta(n^2)$ & $O(n^2)$ & $O(n)$ \\
                \hline
                & Plane Sweep (sweep line) & $\Omega((n + k) \log n)$ & $\Theta(n^2 \log n)$ & $O(n\log n)$ & $O(n)$ \\
                \hline
                & Hierarchical Search &  & $\Theta(n \log n)$ & $O(\log n)$ (query) &  $O(n)$ \\
                \hline
                & LMSR (naive) & $\Omega(n^4)$ & $\Theta(n^4)$ & $O(n^4)$ &  $O(n)$ \\
                \hline
                & LMSR (sweep) & $\Omega(n^2 \log n)$ & $\Theta(n^2 \log n)$ & $O(n^2 \log n)$ &  $O(n)$ \\
                \hline
                & Building $\mathscr{A}$ (hammock) & $\Omega(n^2)$ & $\Theta(n^2)$ & $O(n^2)$ &  $O(n^2)$ \\
                \hline
                & Topological Sweep & $\Omega(n^2)$ & $\Theta(n^2)$ & $O(n^2)$ & $O(n)$ \\
                \hline
                & --- &  &  &  & \\
                \hline
                & Voronoi Diagram & $\Omega()$ & $\Theta()$ & $O()$ & \\
                \hline
                & Delaunay Triangulation & $\Omega()$ & $\Theta()$ & $O()$ & \\
                \hline
                & 3D Convex Hulls & $\Omega()$ & $\Theta()$ & $O()$ & \\
                \hline
                & Range Tree & $\Omega()$ & $\Theta()$ & $O()$ & \\
                \hline
                & Interval Tree & $\Omega()$ & $\Theta()$ & $O()$ & \\
                \hline
                & Treap & $\Omega()$ & $\Theta()$ & $O()$ & \\
                \hline
                & Segment Tree & $\Omega()$ & $\Theta()$ & $O()$ & \\
                \hline
                % & Name & $\Omega(n \log n)$ & $\Theta(n \log n)$ & $O(n \log n)$ & \\
                % \hline
                % & Kirkpatrick's Hierarchical Search && $\Theta(n \log n)$ &  & $O(n)$\\
                % \hline 
                % & & & & & \\
                % \hline
                % & Name & $\Omega(n \log n)$ & $\Theta(n \log n)$ & $O(n \log n)$ & \\
                \hline
                \hline
            \end{tabular}
        \end{center}

        \emph{h is the number of points on $\mathcal{CH}$.}

        \emph{Space complexity is Auxilliary Space plus input size}

        \emph{k is the number of intersections, $k \leq n^2$}

    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \section{CS163 - Topics Overview}
        \begin{description}
            \item[Convex Hull] 
            \item[] 
            \begin{minipage}[h]{0.33\textwidth}
                \begin{itemize}
                    \item[--] Simple Polygons
                    \item[--] Non-Simple Polygons
                    \item[--] Monotone Polygons
                    \item[--] Star-Shape Polygons
                    \item[--] Augmented Tree 
                    \item[--] BBST
                \end{itemize}
            \end{minipage}
            \begin{minipage}[h]{0.33\textwidth}
                \begin{itemize}
                    \item[--] Left Turn/orientation
                    \item[--] Support Line 
                    \item[--] Test for CCW order 
                    \item[--] Test for convexity
                    \item[--] Concatenable Queue 
                    \item[--] Order Decomposable
                \end{itemize}
            \end{minipage}
            \begin{minipage}[h]{0.33\textwidth}
                \begin{itemize}
                    \item[--] Divide\&Conquer 
                    \item[--] Bridge Finding
                    \item[--] Merge Hulls
                    \item[--] Maxima
                    \item[--] Dynamic updates
                \end{itemize}
            \end{minipage}

            \begin{tabular}{lll}
                Algorithm           & time                      & space \\
                \hline
                \hline
                Naive Hull          & $O(n^4)$                  & $O(n)$ \\ 
                Slow Hull           & $O(n^3)$                  & $O(n)$ \\ 
                Jarvis March        & $\Omega(nh)/O(n^2)$       & $O(n)$ \\ 
                Graham Scan         & $O(n\log n)$              & $O(n)$ \\
                Quick Hull          & $\Omega(n\log n)/O(n^2)$  & $O(n)$\\
                MBC                 & $O(n\log h)$              & $O(n)$\\
                Dynamic Hull update & $O(\log^2 n)$             & $O(n\log n)$\\
            \end{tabular}


            \item[Intersecting Points]  
            \item[] 
            \begin{minipage}[h]{0.33\textwidth}
                \begin{itemize}
                    \item[--] Point inclusion
                    \item[--] Status DS 
                    \item[--] Stopping point DS 
                    \item[--] DCEL
                    \item[--] Arrangement, $\mathscr{A}(S)$
                    \item[--] Least Median Square Regression 
                \end{itemize}
            \end{minipage}
            \begin{minipage}[h]{0.33\textwidth}
                \begin{itemize}
                    \item[--] Regularization
                    \item[--] Monotonization
                    \item[--] Triangulating 
                    \item[--] Hierarchical 
                    \item[--] Planar Subdivisions
                    \item[--] Topological Sweep
                    \item[--] UHT and LHT 
                    \item[--] Ready Stack
                \end{itemize}
            \end{minipage}
            \begin{minipage}[h]{0.33\textwidth}
                \begin{itemize}
                    \item[--] $v = n$
                    \item[--] $face \leq 2n - 4$
                    \item[--] $edges \leq 3n - 6$
                    \item[--] Total degrees $\leq 6n - 12$
                    \item[--] Line Sweep
                    \item[--]
                \end{itemize}
            \end{minipage}
            
            \begin{tabular}{lll}
                Algorithm           & time                      & space \\
                \hline
                \hline
                Point inclusion on a convex polygon & $O(\log n)$ & $O(n)$\\
                Line segment intersection (naive) & $O(n^2)$ & $O(n)$ \\
                Line Sweep      & $\Omega((n + k) \log n)/O(n^2 \log n)$   & $O(n)$ \\
                % Line Sweep (BBST)       & $O((n + k) \log n)$   & $O(n)$ \\
                LMSR (naive)            & $O(n^4)$              & $O(n)$ \\ 
                LMSR (vertical sweep)   & $O(n^2 \log n)$       & $O(n)$ \\ 
                Build $\mathscr{A}(H)$: hammock  & $O(n^2)$              & $O(n^2)$ \\
                Topological Sweep       & $O(n^2)$              & $O(n)$ 
            \end{tabular}
            \pagebreak


            %%%%%%%%%
            \item[Voronoi Diagram \& Delauney Triangulation]  
            \item[] 
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] Fortune's Algorithm/Wavefront Sweep
            %         \item[--] CircumCenter 
            %         \item[--]
            %         \item[--]
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] Delauney Triangulation
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] 
            %     \end{itemize}
            % \end{minipage}
            
            \begin{tabular}{lll}
                Algorithm           & time                      & space \\
                \hline
                \hline
                Fortune's Algorithm (VD) & $O(n \log n)$ & $O(n)$  \\
                Naive (VD) & $O(n^2 \log n)$ &  \\
                D\&C (VD) & $O(n \log n)$ &  \\
                DT & $O(n \log n)$ & $O(n)$\\
                3D CH & $O(n \log n)$ &  
            \end{tabular}



            %%%%%%%%%
            \item[3D Convex Hull]  
            \item[] 
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] Preparata \& Hong (D\&C)
            %         \item[--] Shelling's Algo., $\mathcal{P}$ is \# facets
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] Beneath\&Beyond (pyramidal update)
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] Gift Wrapping 
            %     \end{itemize}
            % \end{minipage}
            
            \begin{tabular}{lll}
                Algorithm           & time                      & space \\
                \hline
                \hline
                D\&C & $O(n \log n)$ &  \\
                Merge (sleeve) & $O(n)$ &  \\ 
                Beneath \& Beyond (incremental) & $O(n\log n + n^{\floor*{\frac{d+1}{2}}})$ & \\
                Gift Wrapping & $O(n^{\floor*{\frac{d+2}{2}}})$ &  \\ 
                Shelling & $O(n^2 + \mathcal{P} \log n)$ & 
            \end{tabular}

            %%%%%%%%%
            \item[Linear Programming]  
            % \item[] 
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] 
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] 
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] 
            %     \end{itemize}
            % \end{minipage}
            
            % \begin{tabular}{lll}
            %     Algorithm           & time                      & space \\
            %     \hline
            %     \hline
            %      &  &  \\
            % \end{tabular}


            %%%%%%%%%
            \item[Geometric DS \& Rectilinear Contours]  
            \item[] 
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] 
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] 
            %     \end{itemize}
            % \end{minipage}
            % \begin{minipage}[h]{0.33\textwidth}
            %     \begin{itemize}
            %         \item[--] 
            %     \end{itemize}
            % \end{minipage}
            
            \begin{tabular}{llll}
                Algorithm           & time/query   & space  & preprocess \\
                \hline
                \hline
                1D Range Tree & $Q(\log n + A)$ & $S(n)$ & $P(n\log n)$ \\
                2D Range Tree (naive) & $Q(\log n + |S_1| + |S_2|)$ & $S(n)$ & $P(n\log n)$ \\
                2D Range Tree (better) & $Q(\log^2 n + A)$ & $S(n\log n)$ & $P(n\log n)$ \\
                d-D Range Tree & $Q(\log^d n + A)$ & $S(n\log^{d-1} n)$ & $P(n\log^{d-1} n)$ \\
                Interval Tree & $Q(\log n + A)$ & $S(n)$ & $P(n\log n)$ \\
                1D Segment Tree & $Q(\log n + A)$ & $S(n\log n)$ & $P(n\log n)$ \\
                2D Segment Tree & $Q(\log^2 n + A)$ & $S(n\log^2 n)$ & $P(n\log^2 n)$ \\
                Treap & $Q(\log n + A)$ & $S(n)$ & $P(n\log n)$ \\
                Lipski-Preparata & $O(n\log n + p \log \frac{n^2}{p})$ & $O(n + p)$ &  \\
                Wood & $O(n\log n + p)$ & $O(n + p)$ &  \\
                Guting & $O(n\log n + p)$ & $O(n\log n + p)$  &  \\
            \end{tabular}

        \end{description}
    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \section{Intro: Computational Geometry - A User's Guide (Notes)}
    \label{sec:compgeointro}
    Introduction to algorithims for computations that are geometric in nature. Souvaine \& Dobkin describe some methods with geometric applications.

    Three families of Geometric Algorithms:
    \begin{itemize}
        \item Decomposition of problem into subproblems -- \hyperref[subsec:hsm]{Hierarchical Searching Method} 
        \item Decomposition of problem into subproblems -- \hyperref[subsec:dcm]{Divide and Conquer Method}
        \item Transform a problem into a new (maybe more tractable) format -- \hyperref[subsec:dualitym]{Duality Method}
    \end{itemize}

    Geometric Principles
    \begin{itemize}
        \item Planar Point Location
        \item Convex Hull Construction and Updating
        \item Computation of Polygon
        \item Computation of Disk
        \item Computation of Half-Space Intersections
    \end{itemize}

        %%%
        \subsection{Hierarchical Searching Method}
        \label{subsec:hsm}
            \begin{itemize}
                \item Geometric problem is preprocessed to a coarse representation, such that it can be broken down, and search queries can be called on localized region where the problem is solved. 
                \item Algorithmic efficiency is then balanced against preprocessing time and storage space requirements. 
                \item Binary Search of Sorted Array 
            \end{itemize}

            \subsubsection{\href{https://www.geeksforgeeks.org/binary-search/}{Binary Search} on Geometric Problems}
                \begin{description}
                    \item[Input:] A collection of $N$ disjointed polygons in the plane.
                    \item[Output:] For a given point $P$, find all polygons to which it belongs
                    \item[Naive Solution:] check for $P$ in each points of the polygons. 
                    \item[Rectangle Search I \& II \& III] 
                    \item[General \& Dynamic Polygon Search] 
                \end{description}

        %%%
        \subsection{Divide and Conquer Method}
        \label{subsec:dcm}
        \begin{itemize}
            \item Problem broken into smaller subproblems, and solved recursively. A method is defined for combining solutions to subproblems to come up with solution for entire problem.
            \item Sort-merge
            \item Can work with heierarchical search methods, e.g. divide-and-conquer to sort a set, and then use binary search to find target.
        \end{itemize}

        %%%
        \subsection{Duality Method}
        \label{subsec:dualitym}
            \begin{itemize}
                \item Duality is used as a transformation. Given two sets A and B and a problem about their interrelationship, apply transform T and solve the (ideally simpler) problem about T(A) and T(B).
            \end{itemize}
    \pagebreak
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \section{Convex Hull}
    \label{sec:convexhull}
    Covered in \cite{berg08} CH. 1.1

    HW 1
    
    %%%
    \subsection{Geometry of Convex Hull}
    \begin{figure}[h]
        \centering
        \begin{tabular}{cc}
            \begin{subfigure}{.5\textwidth}
                \centering
                \includegraphics[width=0.5\linewidth]{images/convexhull1.png}
                \caption{}
                \label{fig:convexhull1}
            \end{subfigure} &
            \begin{subfigure}{.5\textwidth}
                \centering
                \includegraphics[width=0.5\linewidth]{images/convexhull2.png}
                \caption{}
                \label{fig:convexhull2}
            \end{subfigure}
        \end{tabular}
        \caption{Example of Convexity}
    \end{figure}

    \begin{itemize}
        \item The computation of \textbf{planar convex hull} was one of the first computational geomtry problems. 
        \item Convexity is important for issues involving point location and intersection detection, all of which have real world applications.
        \item \emph{Convexity 1}: A subset $S$ of the plane is \textbf{convex} if and only if for any pair of points $p, q \in S$, the line segment $\overline{pq}$ is completely contained in $S$. See Fig. \ref{fig:convexhull1}. The \emph{convex hull}, $\mathcal{CH}(S)$, of a set $S$ is the smallest convex set that contains $S$; it is the intersection of all convex sets that contain $S$. 
        \item \emph{Convexity 2}: How to compute the convex hull of a finite set $P$ of $n$ points in the plane? The area enclosed in the shaded region is the convex hull of $P$. See Fig. \ref{fig:convexhull2}. It is the unique convex polygon whose vertices are points from $P$.
    \end{itemize}


    \begin{figure}[h]
        \centering
        \begin{tabular}{cc}
            \begin{subfigure}{.5\textwidth}
                \centering
                \includegraphics[width=0.5\linewidth]{images/convexhull3.png}
                \caption{}
                \label{fig:convexhull3}
            \end{subfigure} &
            \begin{subfigure}{.5\textwidth}
                \centering
                \includegraphics[width=0.5\linewidth]{images/convexhull4.png}
                \caption{}
                \label{fig:convexhull4}
            \end{subfigure}
        \end{tabular}
        \caption{computing convex hull}
    \end{figure}


    \begin{itemize}
        \item Fig. \ref{fig:convexhull3}: To compute a convex hull of a set of points, $P = \{p_1, p_2, ... p_9\}$, we compute a list of those vertices from $P$ that are the vertices of $\mathcal{CH}(P)$, i.e. $\{p_4, p_5, p_8, p_2, p_9\}$, and list them in clockwise order. Defining $\mathcal{CH}(P)$ as a convex polygon is more useful than discussing the intersection of all convex sets. 
        \item Fig. \ref{fig:convexhull4}: For points $p$ and $q$ that are endpoints of an edge and that are in $P$, we direct a line through $p$ and $q$, and if $\mathcal{CH}(P)$ lies to one side, then all points in $P$ must lie to that side of the $\overline{pq}$ line. And if all points of $P \setminus \{p, q\}$ lie to one side of $\overline{pq}$, then $\overline{pq}$ is an edge of the $\mathcal{CH}(P)$.
    \end{itemize}

    From Class, Algorithmic \textbf{Paradigms} covered:
    \begin{itemize}
        \item Sweepline/Incremental 
        \item Divide \& Conquer 
        \item Prune \& Search
    \end{itemize}
    %%%%%%%%%

    %%% 
    \subsection{\textbf{Algorithm} Naive Convex Hull - $O(n^4)$}
    \label{subsec:chn4}
    From class: 

    For set of points in polygon $P$, for every triple $i, j, k$, for every point $l$ not equal to $i, j, k$, if $l \in \Delta ijk$, discard $l$, as point inside the $\Delta$ can't be on the $\mathcal{CH}$. This runs $O(n^4)$ time ($n \times n \times n-1 \times n-2$). $O(n)$ space.
    %%%%%%%%%

    %%%
    \subsection{\textbf{Algorithm} Ways to find Left/Right Turn}
    \label{subsec:turn}
    From class: 

    $\Theta(1)$ time: You can find the counter clockwise (left) or clockwise (right) turn of an angle given three points but calculating the determinant based on the order of the points that they were given in. 

    The determinant is twice the area of a triangle. Given points $A, B, C$, they form a ccw turn if the determinant is positive; o.w. if the area is negative, it is a right turn. This is verified using basic geometry or linear algebra. 
    \begin{align*}
        D &= \begin{vmatrix}
            x_a &  y_a & 1 \\
            x_b &  y_b & 1 \\
            x_c &  y_c & 1
        \end{vmatrix}  
        = x_a \times \begin{vmatrix}
            y_b & 1 \\
            y_c & 1
        \end{vmatrix}
        - y_a \times \begin{vmatrix}
            x_b & 1 \\
            x_c & 1
        \end{vmatrix} 
        + \begin{vmatrix}
            x_b &  y_b \\
            x_c &  y_c 
        \end{vmatrix} \\ 
        &= x_a (y_b - y_c) - y_a (x_b - x_c) + (x_b y_c - x_c y_b) \\
        &= (x_a y_b - x_a y_c) + ( x_c y_a - x_b y_a) + (x_b y_c - x_c y_b) \\
    \end{align*}
    A set of points is a $\mathcal{CH}$ if all the points turn in the same direction. If one different direction is detected, then the polygon is either complex or concave. 
    
    It must also be that, when you transform all vectors $\overrightarrow{v_i v_{i+1}}$ to the origin in that order, no vector crosses over any other, and it must only go around the origin once. Otherwise, it is not convex.
    %%%%%%%%%

    %%%
    \subsection{\textbf{Algorithm} \textsc{SlowConvexHull}($P$) - Naive $O(n^3)$}
    \label{subsec:slowhull}
        \emph{Input}: A set $P$ of points in a plane.

        \emph{Output}: A list $\mathcal{L}$ cotnaining vertices of $\mathcal{CH}(P)$ in clockwise order. 

        \begin{enumerate}
            \item $E \leftarrow \emptyset$
            \item $\forall$ ordered pairs $(p, q) \in P \times P$, where $p \neq q$
            \item \hspace{0.5cm} \textbf{do} \emph{valid} $\leftarrow$ \textbf{true}
            \item \hspace{1cm} $\forall r \in P, r \neq p, r \neq q$
            \item \hspace{2cm} \textbf{do} \textbf{if} $r$ lies to the left of directed line from $p$ to $q$
            \item \hspace{3cm} \textbf{then} \emph{valid} $\leftarrow$ \textbf{false}
            \item \hspace{1cm} \textbf{if} \emph{valid} \textbf{then} Add add directed edge $\overrightarrow{pq}$ to $E$.
            \item From the set $E$ of edges, construct a list $\mathcal{L}$ of vertices of $\mathcal{CH}(P)$, sorted in clockwise order. 
        \end{enumerate}

        \begin{itemize}
            \item This is ``piecewise linear'' in finding the edges of a polygon.
            \item ``Supporting Line'' is such that all points of the polygon is on the line or to one side of the line (on the closed half plane).
            \item \emph{*Assume for now that methods to test if a point is to the right or left of a line is available. Assume this primative operation is O(1).}
            \item \emph{*initially ignores the degenerate case, where a point r may lie on $\overrightarrow{pq}$}. To consider the degeneracy, must specify that $\overrightarrow{pq}$ is an edge of $\mathcal{CH}(P)$ if and only if all other $r \in P$ lie strictly on the right or left of $\overrightarrow{pq}$, or they lie on the open line segment $\overline{pq}$.
            \item \emph{Problems with rounding error could arise should coordinates are represented in floating point numbers, leading to unexpected results.}
            \item Constructing $\mathcal{L}$ takes about $O(n^2)$ time. For an edge $e_1 \in E$, take the source and destination points, add them to $\mathcal{L}$. Using the destination point of $e_1$, find the $e_2$ that has that as it's origin, and add $e_2$'s destination point to $\mathcal{L}$. Repeat until only one edge is left in $E$. 
            \item Complexity Analysis: 
                \begin{itemize}
                    \item Check each of the $n^2 - n$ \emph{pairs} of points. For each pair, look at $n - 2$ other points to see if they lie to one side. Total: $O(n^3)$.
                    \item Constructing $\mathcal{L}$ is $O(n^2)$.
                    \item Total overall: $O(n^3)$.
                    \item Space: $O(n)$
                \end{itemize}
        \end{itemize}
        %%%%%%%%%


    %%%
    \subsection{\textbf{Algorithm} Jarvis March (Gift Wrapping) - $O(n^2)$}
    \label{subsec:giftwrapping}
    \url{https://iq.opengenus.org/gift-wrap-jarvis-march-algorithm-convex-hull/}

        \begin{itemize}
            \item Sweepline/Incremental algorithm 
            \item Starting with an extreme point (leftmost/rightmost/etc.), and keep wrapping the points in ccw direction. 
            \item Finding the \emph{next} point involves calculating if the the next candidate makes a ccw orientation with the previous two points. Decide on the directionality, but essentially: 

            \begin{itemize}
                \item Caclulate all the slopes from current point with all the other points. 
                \item Pick the point that gave use the minimum slope. 
                \item The min slope point is now the current point. Repeat this process until we return to the first point. 
                \item \emph{You may need to pick a directionality when you get to the other extreme and start to ``turn around''.}
            \end{itemize}

            \item This algorithm is output sensitive. So runtime is $O(nh)$, and worst is when $h = n$.
        \end{itemize}

    %%%%%%%%%


    %%%
    \subsection{\textbf{Algorithm} ConvexHull($P$) - Incremental Algorithm $O(n \log n)$}
    \label{subsec:chinc}

        Needs only a sorting method and a method to test if three points can make a right turn. \cite{berg08}

        Briefly: Given the set $P$ of points on a plane, sort the points $p_1, ..., p_n$ ordering them by their x-coordinate. Compute the convex hull vertices on the \emph{upper hull} first, from left to right, from point $p_1$ to $p_n$. Then compute the convex hull vertices of the \emph{lower hull} from right to left, from $p_n$ to $p_1$. 

        Updating of the upper hull after adding point $p_i$ is important. Suppose there is a list $\mathcal{L}_{up}$ containing the left to right upper hull vertices seen thus far, $\{p_1, ..., p_{i - 1}\}$. Append $p_i$ to $\mathcal{L}_{up}$. It is correct if $p_i$ is the rightmost point so far, and if the last three points in $\mathcal{L}_{up}$ make a \emph{right} turn. Move on to $p_{i+1}$ if $p_i$ can be in the upper hull thus far. If a left turn is made, delete the middle point from the upper hull, and keep rechecking the last three points until a right turn is verified.

        \begin{figure}[h]
            \centering
            \begin{tabular}{cc}
                \begin{subfigure}{.5\textwidth}
                    \centering
                    \includegraphics[width=0.5\linewidth]{images/chalgo1.png}
                    \caption{}
                    \label{fig:chalgo1}
                \end{subfigure} &
                \begin{subfigure}{.5\textwidth}
                    \centering
                    \includegraphics[width=0.5\linewidth]{images/chalgo2.png}
                    \caption{}
                    \label{fig:chalgo2}
                \end{subfigure}
            \end{tabular}
            \caption{Convex Hull Algorithm. In (b), the order of those points being deleted is right to left, as $p_i$ is the rightmost point thus far being checked for inclusion in the convex hull.}
        \end{figure}


        \emph{Input}: A set $P$ of points in a plane.

        \emph{Output}: A list $\mathcal{L}$ cotnaining vertices of $\mathcal{CH}(P)$ in clockwise order. 

        \begin{enumerate}
            \item Sort the points by x-coordinate, resulting in sequence $p_1, ..., p_n$.
            \item Put $p_1$ and $p_2$ in $\mathcal{L}_{up}$, with $p_1$ as the first point. 
            \item \textbf{for} $i \leftarrow 3$ \textbf{to} $n$
            \item \hspace{1cm} \textbf{do} Append $p_i$ to $\mathcal{L}_{up}$
            \item \hspace{2cm} \textbf{while} $| \mathcal{L}_{up} | > 2$ \textbf{and} the last three points in $\mathcal{L}_{up}$ don't make a right turn, 
            \item \hspace{2.5cm} \textbf{do} delete the middle of the last three points in $\mathcal{L}_{up}$
            

            \item Put points $p_{n}$ and $p_{n - 1}$ in $\mathcal{L}_{low}$, with $p_n$ as the first point. 
            \item \textbf{for} $i \leftarrow n - 2$ \textbf{down to} 1
            \item \hspace{1cm} \textbf{do} Append $p_i$ to $\mathcal{L}_{low}$
            \item \hspace{2cm} \textbf{while} $| \mathcal{L}_{low} | > 2$ \textbf{and} the last three points in $\mathcal{L}_{low}$ don't make a right turn, 
            \item \hspace{2.5cm} \textbf{do} delete the middle of the last three points in $\mathcal{L}_{low}$
            
            \item Remove the first and last points from $\mathcal{L}_{low}$ (avoid duplicate points of where upper and lower hull meet).
            \item Append $\mathcal{L}_{low}$ to $\mathcal{L}_{up}$, call the result $\mathcal{L}$
            \item \textbf{return} $\mathcal{L}$
        \end{enumerate}

        \begin{itemize}
            \item We assumed no two points have the same x-coordinate. To consider that, sort same-x-coord points by their y-coord.
            \item We will say for three collinear points (make a straight line), they make a left turn.
            \item Points very close together could create sharp left turns. For these, consider them the same point by rounding.
            \item Algorithm will compute a closed polygonal chain. 
            \item \textbf{Theorem} \emph{The convex hull of a set of n points in the plane can be computed in $O(n \log n)$ time}.
            \item \textbf{Proof}: See \cite{berg08} page 8. 
                \begin{itemize}
                    \item Correctness of computation of upper hull (and lower) is proof by induction. Briefly, the set $\mathcal{L}_{up}$ of $\{p_1, p_2\}$ is trivially the upper hull. $\mathcal{L}_{up}$ containing the chain $\{p_1, ..., p_{i - 1}\}$ is known, by induction to only make right turns, and that all points fall below the chain. When considering point $p_i$, be know that $p_1$ is the smallest point and $p_i$ will be the biggest point thus far. There can be no points above the old chain, because if there were, then it would have to lie between $p_{i-1}$ and $p_i$ in sorted order. 
                    \item Sorting the points can be done in $O(n \log n)$ time. Computing upper hull is done in $O(n)$ time, because the for loop is executed a linear number of times, as any extra executions (from the while loop) is bound by $n$ since extra points can only be deleted onces during the hull construction. Similarly, lower hull construction is $O(n)$ time. Therefore total time for computing convex hull is $O(n \log n)$. 
                    \item Space is $O(n)$.
                \end{itemize}
        \end{itemize}


        \begin{figure}[h]
            \centering
            \includegraphics[width=0.3\linewidth]{images/chalgo3.png}
            \caption{Convex Hull Algorithm - Correctness}
            \label{fig:chalgo3}
        \end{figure}
        %%%%%%%%%
            

    %%%
    \subsection{\textbf{Algorithm} Graham Scan - $O(n \log n)$}
    \label{subsec:gscan}
        \url{https://iq.opengenus.org/graham-scan-convex-hull/}

        \begin{itemize}
            \item See Section \ref{subsec:chinc} for the $O(n \log n)$ time due to the pre-sorting. Forming a hull after sorting is $O(n)$ time. $O(n)$ space.
            \item Uses a stack to remove concavities. Incremental.
            \item The runtime rather comes from finding a central position (or even any), calculating all their polar angles (or slopes), and \emph{sorting} them by the angles first. This algorithm comes with a \textbf{Pre-processing} step.
            \item Add the smallest y-coord point to the stack (finding it takes $O(n)$ time), add the next two points in the order to the stack (pre-processing took $O(n\log n)$). Calculate their orientation. The the next point is a candidate; calculate the orientation of the candidate and top two points in the stack. If you get the same orientation, add cancdidate to stack move on to next point; else, pop the stack, and check again. Repeat the popping until you get the orientation desired. Every element is pushed and popped from the stack at most once, and assuming each stack operation takes $O(1)$, so forming the hull is $O(n)$. 
        \end{itemize}
    %%%%%%%%%

    %%%
    \subsection{Bridges}
    \label{subsec:bridge}
        
        \begin{itemize}
            \item A \emph{bridge} is the support line that forms the edge of $\mathcal{CH}$ or one that forms a new $\mathcal{CH}$ edge between two convex polygons when we want to form a new convex hull from their merge. 
            \item Bridge finding is the goal of a divide and conquer method for finding convex hulls.
            \item Bridge finding takes logarithmic time. And there are 8 cases to examine. See Notes and Section \ref{subsec:dynamichull}.
        \end{itemize}

    %%%%%%%%%

    %%%
    \subsection{General Divide \& Conquer Convex Hull Methods}
    \label{subsec:dchull}
        
        \begin{itemize}
            \item Typically $T(n) = 2\ T(\frac{n}{2}) + \Theta(n)$. Outline for an unsorted set of points $S$:
                \begin{itemize}
                    \item \emph{assume pre-sort; or sort ($O(n \log n)$)}
                    \item Find $\mathcal{CH}(S, 1, \frac{n}{2})$ (``left'')
                    \item Find $\mathcal{CH}(S, \frac{n}{2} + 1, n)$ (``right'')
                    \item Merge the $\mathcal{CH}$'s
                \end{itemize}
            \item Something like binary search ($O(\log n)$) can be used to find the bridge, for $T(n) = 2\ T(\frac{n}{2}) + \Theta(\log n)$.
            \item Some useful data structures, such as \textbf{concatenable queue}, can make inserting a point, deleting a point, or finding a point, splitting, joining (implant) take time $O(\log n)$.
        \end{itemize}

    %%%%%%%%%

    %%%
    \subsection{\textbf{Algorithm} Quick Hull - $O(n^2)$}
    \label{subsec:quickhull}
        \url{https://iq.opengenus.org/quick-hull-convex-hull/}

        \url{https://www.geeksforgeeks.org/quickhull-algorithm-convex-hull/}

        \begin{itemize}
            \item Like quicksort. Divide and Conquer method.
            \item Find the leftmost and rightmost points, $\ell$ and $r$. 
            \item Find the highest and lowest points relative to the $\overline{\ell r}$ slope. We call this extreme point $e$ 
            \item Form a triangle with $\ell$, $r$, and $e$. Discard all points inside triangle $\Delta \ell r e$. 
            \item Repeat this process with one of $\ell$ or $r$, and the $e$ you picked (i.e. one of the new edge of the triangle).
            \item Best case is $O(n\log n)$. Worse case is $O(n^2)$ if all points are in the convex hull.
        \end{itemize}

    
    %%%
    \subsection{\textbf{Algorithm} Ultimate Planar Convex Hull (Marriage Before Conquest ) - $O(n \log h)$}
    \label{subsec:ultimatehull}

    \url{https://iq.opengenus.org/kirkpatrick-seidel-algorithm-convex-hull/}

    \cite{kirk1986}

        \begin{itemize}
            \item Prune \& Search. Output sensitive.
            \item Runs in $O(n\log h)$ time, where $h = |\mathcal{CH}(S)|$. Even in worst case, where every point is in the hull, time is still $O(n \log n)$ like Graham's Scan.
            \item Instead of recurisng on each half after splitting the set like in a D\&C, this computes how the sets should be merged, then recurse on subsets. This finds upper hull, and then when you find the lower hull, the two sets can be concatenated.
            \item Briefly: \emph{Given a set, find the median vertical. Next goal is to find the bridge that crosses the median vertical. By definition of $\mathcal{CH}$, all points beneath this line is not in the $\mathcal{CH}$, so you discard/prune these points. The remaining points are split into the $L$ and $R$ subsets, and you recurse on them}. 
            \item This is also useful when you have two disjointed convex hulls and want to merge them; simply find the bridge that crosses the median between the two hulls, as opposed to trying all the vertex combinations.
            \item The Kirkpatrick-Seidel algorithm:
            \begin{enumerate}
                \item \emph{don't sort!}
                % \item Split the points in half, the $L$ set and the $R$ set.
                % \item Find the bridge between $L$ and $R$:
                \item Find the median vertical of the set of points ($T(n) = T(\frac{n}{5}) + T(\frac{2n}{4}) + \Theta(n) = \Theta(n) = \Theta(n)$).
                \item PAIRING: Randomly pair up the points, and calculate the misc. slopes. We have $\frac{n}{2}$ pairs.
                \item Find the median slope ($O(n)$), $m_{\text{median}}$.
                \item Calculate all the y-intercept of all the points if they have slope $m_{\text{median}}$. ``Sweep slope of $m_{\text{median}}$'', and find the most extreme max y-intercept, $b_{\text{max}}$.
                \item BridgeFind: $T_{\text{bridge}}(n) \leq T_{\text{bridge}}(n - \floor*{\frac{n}{4}}) + O(n) = O(n)$
                
                This is when we start removing points that don't meet our criteria:

                \begin{enumerate}
                    \item rotate the line $y_b = m_{\text{median}} x_b + b_{\text{max}}$. Find the bridge with the first point you hit. 
                    \item For the example where $b_{\text{max}}$ is on the right side and has a negative slope for $m_{\text{median}}$, if it his a point that is paired with a point that forms a negative slope, discard the lower point, as you can only ever hit the upper point to be on the hull. Keep all other points. 
                    \item More succinctly, for this pruning step, using the extreme point, $p_{\text{max}}$, you found:
                    \begin{itemize}
                        \item If $p_{\text{max}}$ is on the \emph{right} of line $x_\text{median}$ (where $x_{p_\text{max}} > x_\text{median}$), for every line with a slope less than $m_{\text{median}}$, discard its lower/right point.
                        \item If $p_{\text{max}}$ is on the \emph{left} of line $x_\text{median}$ (where $x_{p_\text{max}} < x_\text{median}$), for every line with a slope greater than $m_{\text{median}}$, discard its upper/left point.
                    \end{itemize}
                    \item This process discards $\frac{1}{4}$ of the points in the set, the pruning. 
                    \item Repeat from the PAIRING step until 2 points are left. These are the points of the Bridge.
                    \begin{equation*}
                        T(n, h) \leq \begin{cases}
                            0 &\text{if } h = 1 \\
                            O(n) &\text{if } h = 2 \\
                            T(\frac{n}{2}, h_l) + T(\frac{n}{2}, h_r) + T_{\text{bridge}}(n) &\text{if } h \geq 3, \\
                            & \text{where } h_l + h_r = h, h_r, h_l \geq 1
                        \end{cases}
                    \end{equation*}

                \end{enumerate}

             

                \item Repeat from step 2 for remainder subsets $L$ and $R$ on either side of the bridge.
            \end{enumerate}
        \end{itemize}

        \textbf{Proof}

        \emph{Claim:} $T_{\text{bridge}}(n) \leq T_{\text{bridge}}(n - \floor*{\frac{n}{4}}) + O(n)$

        Show by induction on size of $h$ that $T(n, h) \leq c n \log h$. 

        \emph{Basis:} If $h = 2$ (minimum for top hull of the $\mathcal{CH}$), the top edge has at least 2 points. (\emph{$\log 2 = 1$}). $$ T(n, 2) = c_1 n \leq cn \log 2 \hspace{2cm} \text{(pick $c \geq c_1$)}$$

        \emph{Inductive Hypothesis:} $T(n, h) \leq ch \log h$, for $h\leq k$.
        
        \emph{Inductive Step:} 
        \begin{align*}
            T(n, h) &\leq c_1 n + T(\frac{n}{2}, h_l) + T(\frac{n}{2}, h_r) \\
            &\leq c_1 n + \frac{cn}{2} \log h_l + \frac{cn}{2} \log h_r \\
            &\leq c_1 n + \frac{cn}{2} (\log h_l + \log h_r) \\
            &\leq c_1 n + \frac{cn}{2} \log (h_l h_r) \\
            &\leq c_1 n + \frac{cn}{2} \log (h_l (h - h_l)) \\
            &\leq c_1 n + \frac{cn}{2} \log (\frac{h}{2})^2 \\
            &\leq c_1 n + cn \log (\frac{h}{2}) \\
            &\leq c_1 n + cn \log h - cn \log 2\\
            &\leq cn \log h \hspace{2cm} \text{if } c = c_1 \\
        \end{align*}

    %%%%%%%%%

    %%%
    \subsection{\textbf{Algorithm} Dynamic $\mathcal{CH}$ / Order Decomposable Problem - $O(\log^2 n)$}
    \label{subsec:dynamichull}

        \url{https://www.geeksforgeeks.org/dynamic-convex-hull-adding-points-existing-convex-hull/}

        See Dynamic Convex Hull Notes.

        See user guide section on this.

        \begin{itemize}
            % \item Order Decomposable Problem, Point Inclusion, Detecting Intersection 
            \item Convex Hull construction is Order-Decomposable: we define some ordering function and merging function, where the merging operates iteratively on the ordered input set. 
            \item This algorithm addresses when we want to to ADD a new point to or DELETE a point from the current set that we already computed the convex hull for. This avoids recalculating the entire set for changes regarding single points. Recalculating a $\mathcal{CH}$ is of cource $O(n \log n)$ time, but we want a single update to take only $O(\log^2 n)$ time, and make our algorithms dynamic for these updates.
            \item Using a concatenable queue makes bridge finding between two hulls is $O(\log n)$; then we can concatenate the left portion of the left hull with the right portion of the right hull. This relies on sorting the points though, so sorting dominates the runtime at $O(n \log n)$, while the merge gives a recurrance of $T(n) = 2 T(\frac{n}{2}) + O(\log n) = O(n)$.
            \item Best to use a dynamic (augmented) tree as the data structure. The root contains the points of the $\mathcal{CH}$, while the subtrees/node has info about the partial hulls, and can point to another tree. We can retain the info of points that aren's in the $\mathcal{CH}$. The leaves are the actual data/points. 
            \item There are 8 cases to examine to find the bridge between hulls $A$ and $B$. See Class Nodes for Dynamic Convex Hull. But succinctly, when examining if line $\overline{ab}$ could be the bridge, we consider the angles given by $a$ and its neighbors and by $b$ and its neighbors ($\angle a_l\ a\ a_r$ and $\angle b_l\ b\ b_r$), the angles are relative to the line $\overline{ab}$: 
            \begin{enumerate}
                \item $\angle a_l\ a\ a_r$, $\angle b_l\ b\ b_r \leq 180^{\circ}$ (both edges of each angle are above $\overline{ab}$) $\longrightarrow$ $\overline{ab}$ is the bridge.
                \item $\angle b\ a\ a_l \geq 180^{\circ}$ ($\overline{a\ a_l}$ falls ``below'' $\overline{ab}$) $\longrightarrow$ points $a$ and all to the right of $a$ (``above'' $\overline{ab}$) can't be the bridge point, discard. The bridge will be found in $B$ and the left subchain of $A$ from $a$. 
                \item $\angle a\ b\ b_r \geq 180^{\circ}$ ($\overline{b\ b_r}$ falls ``below'' $\overline{ab}$) $\longrightarrow$ points $b$ and all to the left of $b$ (``above'' $\overline{ab}$) can't be the bridge point, discard. The bridge will be found in $A$ and the right subchain of $B$ from $b$. 
                \item Both $\angle a_l\ a\ a_r, \angle a_r\ a\ a_l > 90^{\circ}$ (both $\overline{a\ a_r}$ and $\overline{b\ b_l}$ fall ``below'' $\overline{ab}$, and their vectors extended intersect at point $v = (x, y)$). Let $M_A$ be the max x-coord of $A$, and let $m_B$ be the min x-coord of $B$. There is a region between $M_A$ and $m_B$:
                \begin{enumerate}
                    \item $x < M_A$ and $x < m_B$ ($x$ is to the left of the region), then no points on the left subchain of $A$ including $a$ can be a bridge point. Remove those points.
                    \item $x > m_B$ and $x > M_A$ ($x$ is to the right of the region), then no points on the right subchain of $B$ including $b$ can be a bridge point. Remove those points.
                    \item $M_A < x < m_B$ ($x$ is in the region), then no points on the left subchain of $A$ including $a$ and no points on the right subchain of $B$ including $b$ can be a bridge point. Remove those points.
                \end{enumerate}
                \item Only $\overline{b\ b_l}$ falls below $\overline{ab}$ $\longrightarrow$ discard the right subchain in $A$ and $B$.
                \item Only $\overline{a\ a_r}$ falls below $\overline{ab}$ $\longrightarrow$ discard the left subchain in $A$ and $B$.
            \end{enumerate}

            \item This bridge finding process can run in $O(\log n)$ time. And since out DS is an augmented tree, the total runtime to apply the update is $O(\log^2 n)$.
        \end{itemize}


        Some Order-Decomposable Problems: 
        \begin{itemize}
            \item Finding intersection of Half Plane 
            \item Finding the set of Dominant Points (Maxima) 
            \item Finding top and bottom of a polygon with tertiary search in sub-linear time
        \end{itemize}

    %%%%%%%%%

    %%%
    \section{Point Inclusion}
    \label{sec:ptincl}

    \begin{itemize}
        \item It is $O(\log n)$ time to test point inclusion with a convex polygon.
        \item This problem can get more complex as the polygon gets more complex. For example, point inclusion with an x-monotone polygon, arbitrary polygon.
        \item For more complex polygons, you can regularize them into planar subdivisions, and test point inclusion on the convex polygons they breaks down into.
        \item There is a Slab Method for Planar Point Location (Dobkin and Lipton)
        \item Future sections address these more complex spaces.
    \end{itemize}



    %%%%%%%%%%%


    %%%
    \subsection{3D Convex Hull}
    \label{subsec:3dconvexhull}
    Introduced (background) in \cite{berg08} CH. 11
    %%%%%%%%%

    \pagebreak
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % INTERSECTING POINTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \section{Intersecting Points}
    Covered in \cite{berg08} CH. 2-3, 6

    HW 2

    \subsection{Intro to Intersecting Points}
        \begin{itemize}
            \item Naively find intersecting points of a set $S$ of $n$ line segments is for each segment $s \in S$, find its intersections with all other segments $q \in S$. $O(n^2)$.
            \item We want \emph{output sensitive} or \emph{intersection sensitive} algorithms. 
            \item \textbf{Plane sweep algorithms}: 
                \begin{itemize}
                    \item Uses \emph{status} DS to keep track of lines that currely intersect. It updates when we change the sweep line. The updates happen at \emph{event} or \emph{stopping points}, also kep in a DS. At a stopping point, algorithm updates the status of sweep line, and perform intersection tests. At a point on a line, the start of it when we add it to the status, calculate the intersections of the  line against those lines already in the status DS. Currently, this algorithm is \emph{not} output sensitive.
                    \item Improvements: Only test for intersections on the line with its neighbor lines (at most, test current line against two other lines). This also \emph{orders} the segments in the status DS, so we are delivering the intersection points in order, as well. Stopping point DS now also includes intersection points.  
                \end{itemize}
            \item Special cases to think about later:
                \begin{itemize}
                    \item overlapping lines
                    \item more than two lines intersect at one point 
                    \item line segment has a slope matching the sweeping lstinline
                \end{itemize}    

            \item 
        \end{itemize}

    %%% 
    \subsection{\textbf{Algorithm} Intersections: Line Segment Intersections / Plane Sweep - $O(n^2 \log n)$}
        \begin{itemize}
            \item Let two lines $\overline{a_0 a_1}$ and $\overline{b_0 b_1}$ intersect at a point $p$. 
            
            \begin{itemize}
                \item Using the sweep line method, there is an event/stopping point \emph{before} $p$ that reveals $\overline{a_0 a_1}$ and $\overline{b_0 b_1}$ are adjacent and therefore get tested for intersection. We are specifically at a point of the sweep line such that i there are no other event points on the sweep line or between the it and the line given by the line's slope and point $p$. When $A$ and $B$ are not yet adjacent, this is when the sweep line is above all the segments, so there is nothing in the status DS. So ther must be an event point $q$ when $A$ and $B$ become adjacent and are tested for intersection.
            \end{itemize}

            \item Stopping points shall include endpoints AND the intersections points calculated along the way that are to the sweeping direction of the sweeping line (no looking backwards at points already detected). 
            \item The status DS shall maintain the ordered sequence of segments that the sweeping line intersects (the stabbing points of sweep line $\ell$).
            \item At a halting point, algorithm must update the status DS and find intersections (if any new). 
            
                \begin{itemize}
                    \item Example (first Endpoint Event): Suppose $s_i$ and $s_k$ are adjacent. The next event is a new line's endpoint of $s_j$. Updating status reveals that $s_j$ is adjacent to $s_i$ and $s_k$. We see that $s_j$ and $s_i$ have an intersecting point, $p$. So we make $p$ a new stopping point. Then move on to next event point. 
                    \item Example (Intersection point event): This is when two lines that intersect cross, so their ordering in the status DS changes. Both shall get at most one new neighbor, for which new intersections must be calculated. Let these be adjacent in order: $s_j\ s_k\ s_l\ s_m$. Let the current event be the intersection of $s_k\ s_l$. $s_k\ s_l$ must switch order, and the new intersections, if any, between new neighbors, $s_j\ s_l$ and $s_k\ s_m$, are calculated and added to the stopping point DS. This can be done if lines were previously found to be adjacent before. 
                    \item Example (second Endpoint Event): Suppose the status order of lines $j\ k\ l$, $k$ is adjacent to its neighbors $j$ and $l$. We reach event of the second endpoint of $k$ (so $k$ shall be leaving status DS). This means $j$ and $l$ will be neighbors and thier intersections gets calculated and put in stopping point DS. 
                \end{itemize}
            
            \item \textbf{Invariant}: All intersection points behind the sweep line have been computed correctly. 
            \item \textbf{Data Structures}:
            
                \begin{itemize}
                    \item \textbf{Stopping Point/Event Point}: Using an event queue or a modified Balanced Binary Search Tree. Ordering will depend on how the $\ell$ sweeps. If $\ell$ is vertical and sweeps along the x-direction, then order by x-coord, and pick the point with the smaller y-coord if two events share the same x. Likewise, if $\ell$ is horizontal and sweeps down the y-direction, then order by y-coord, and pick the point with the smaller x-coord if two points have the same y. Fetching next event and inserting new even is $O(\log m)$ time where $m$ is the number of events. This lets us test whether an event is already in the BBST. During creation (initialization is $O(n\log n)$ for a BBST), we fill the stopping point DS with just endpoints. For each starting endpoint, we store its segment with it. The algorithm runs every time we pop a new event odd and handle it, and runs until the event queue is empty. \emph{See page 26 of \cite{berg08} for full detail on handling all kinds of event points, including degenerates.} 
                    \item \textbf{Status SD}: Using a BBST, which must be dynamic to deal with line segments going in an out as they intersect or stop intersecting $\ell$. The actual ordering will be in the leaves of the BBST. Each update and neighbor operation takes $O(\log n)$
                \end{itemize}
            
            \item Runtime is $O((n + k)\log n)$, where $n$ is the number of segments in the input set, and $k$ is the size of output (we can specify number of intersections, which doesn't double count when more than 2 segments intersects at a common point). 
            \item Status DS is $O(n)$ space. Stopping point DS is $O(n + I)$ space, where $I$ is number of intersections. It may actually be $O(n)$ if we remember to remove intersection points when segments are no longer adjacent, as the intersections will go back in again if they have not been report and their segments become adjacent again later.
        \end{itemize}
        \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Hierarichal Search (Triangles)}
        \begin{itemize}
            \item $O(n)$ space 
            \item Preprocessing is $O(n\log n)$ 
            \item Query time is $O(\log n)$
            \item Reference point is in a $\Delta$, so the $\Delta$ can be divided into three triangles. Continue dividing it until we reach bottom. 
            \item Example 
                \begin{itemize}
                    \item $v = n = 5$ 
                    \item $f \leq 2n - 4 = 6$ 
                    \item $e \leq 3n - 6 = 9$ 
                    \item average degree $< 6$ 
                    \item Total degree $\leq 6n - 12$. 
                \end{itemize}
            \item Space: $S(n) = n + S(\frac{23n}{24}) = \Theta(n)$
        \end{itemize}
    %%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%
    \subsection{\textbf{Algorithm} Line Sweep - $O((n + k) \log n)$}
        \begin{itemize}
            \item A naive algorithm is to visit every intersection point in the place. $O(n^2)$ time for $O(n^2)$ intersections for $n$ lines. 
            \item If we use a line sweep, the choice in status and stopping point data structure can affect run time. 
            \item Status array and Stopping priority queue gives us $O(n^2 \log n)$ time and $O(n)$ space.
            \item BBST status and stopping DS can give us 
            \item Status array and Stopping priority queue gives us $O((n + k) \log n)$ time and $O(n)$ space, for $n$ line segments with $k$ intersections. The key is to have the status only contain the current stabbed lines in order based on who they are adjacent to, and the stopping point DS should only contain the intersections of current neighors. This involves a lot of updates, but updates in a BBST is only $O(\log n)$ time. Sweep line is output sensitive.
        \end{itemize}
    %%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Regularizing Planar Subdivisions and Triangulating}
        \begin{itemize}
            \item Turning an arbitrary polygon into monotone regions takes $O(n\log n)$ time. 
            \item Turning a monotone polygon into triangles takes $O(n)$ time using a DCEL.

                \begin{itemize}
                    \item Preprocessing: $O(n)$ time 
                    \item Triangulating: $O(n)$ time
                \end{itemize}

            \item Testing a point for inclusion in a triangle is $O(1)$.
        \end{itemize}
    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Doubly Connected Edge List (DCEL)}
        \begin{itemize}
            \item 
            \item DCEL contains a record for each face, edge, and vertex of a planar subdivision. (In application, it is useful for these records to also contain attribute information, such as what is in a given face.)
        \end{itemize}
    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%
    \section{Polygon Triangulation}
    See CH. 3 of \cite{berg08}

    HW 2

    \subsection{Art Gallery Problem with 3-coloring Approach - $O(n\log n)$}
        \begin{itemize}
            \item For triangulation of the polygon, it should deliver a DCEL, which allows for constant time stepping into another triangle/face of the triangulated polygon. This should be $O(n\log n)$ time.
            \item Depth-first search can be used to compute the 3-coloring of the vertices of all the triangles, which should take $O(n)$ time.
            \item There are at most $\floor*{n / 3}$ camera placements to find in a polygon of $n$ vertices. The worst case being the comb-shaped polygon.
        \end{itemize}
    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Triangulation: Partitioning a Polygon into Monotone Pieces}

        \begin{itemize}
            \item $O(n^2)$ if we take $O(n)$ for each vertex to find a proper diagonal to make a triangle. 
            \item $O(n)$ is we know polygon is convex, so we simply take the segments from one vertex to all other vertices, and we have our triangulation.
            \item Potential but hard strategy is to decompose the polygon into convex polygons and triangluate the sub-convex-polygons. However, we instead take an easier strategy: Decompose the polygon into monotone pieces, and triangulate those. 
            
                \begin{itemize}
                    \item Partition into (y-)Montone pieces with diagonals: When walking from the topmost to bottomost vertices, we detect the direction we are going, namely dowards. A turn vertex is when the direction changes. So at that vertex, if the two incident edges of the turn vertex lie below it and the interior of the polygon above it, then the diagnonal for $v$ must be above $v$. Likewise, if the two incident edges of $v$ lie above $v$, then the diagonal should be below $v$. See page 50 in \cite{berg08}
                \end{itemize}

        \end{itemize}
    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%

    %%%%%%%%%%%%%%%%%%%%%%%
    \section{Least Median Square Regression}
    \label{sec:lms}

        \begin{itemize}
            \item To find a subset of a set that contains $\ceil*{\frac{n}{2}}$ of the data points:
            
            \begin{itemize}
                \item Naive: For every triple $i, j, k\in S$, make parallel lines through $k$ and $\overline{ij}$, and check if $\ceil*{\frac{n}{2}}$ are in that slab. $O(n^4)$ time. 
                \item 
            \end{itemize}




            \item 
        \end{itemize}


        \subsection{Duality}
        \label{subsec:dual}
            
        \begin{itemize}
            \item These mappings hold from primal to dual and back:
            
            \begin{itemize}
                \item $(a, b) \mapsto y = ax + b$
                \item $y = cx + d \mapsto (-c, d)$
            \end{itemize}

            \item Vertical Distance is preserved. 
            
            \item For a set of $n$ points in $S$, we can transform each point $p \in S$, where $p = (a, b)$, into the dual, so $T(p) = ax + b$. In the dual, we now have an arrangement of lines, which we can \emph{sweep} over. Sinve vertical distance is preserved, we simply pick the ``height'' $h$ we want, and at each stopping point in the sweep, we select the $h$ adjacent neighbors (cuts) and record that distance. Typically, the goals is to find the ``tightest'' fit, or shortest distance that will contain $\ceil*{\frac{n}{2}}$ of the data points. That gives us out LMSR.
            
            \item In the dual: 
            
            \begin{itemize}
                \item Points on the same segment in the primal will intersect in the dual at the pencil point ($y = cx + d \mapsto (-c, d)$).
                \item The two regions created in the dual is known as dowble wedge.
                \item If two primal segments intersect, then each of their pencils are in a wedge of the other ni the dual 
                \item if two primal segments don't intersect unless both their lines extend, then neither pencils is in the wedge of the other in the dual, but their wedges may overlap.
                \item if two primal segments don't intersect unless one of the segments extends, then the pencil of the non-extended one lives in the wedge of the other in the dual.
            \end{itemize}

        \end{itemize}




        \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%
    
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   

    \section{Voronoi Diagrams}
    \label{sec:voronoi}

    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth]{images/voronoi1.png}
    \end{figure}

    \begin{itemize}
        \item The voronoi diagram of a set $P$ of $n$ points is denoted Vor($P$). It may simply refer to the set of the edges and vertices that make up the diagram. The actual points in the set are known aas voronoi sites. 
        \item Each cell in Vor($P$) is denoted $\mathcal{V}(p_i)$, if the voronoi site is given by point $p_i \in P$.
        \item The edge between $p_i, p_j \in P$, $i \neq j$, is given by the perpendicular bisector of $\overline{p_i p_j}$. 
        \item For $n$ sites, each $\mathcal{V}(p_i)$ has at most $n-1$ vertices and edges; but actually, using \emph{Euler's formula}, for $n \geq 3$, the entire Vor($P$) has at most $2n - 5$ vertices, and $3n - 6$ edges. The complexity of  Vor($P$) is linear. 
    \end{itemize}

    \begin{figure}[h]
        \begin{tabular}{cc}
            \begin{subfigure}{0.5\linewidth}
                \centering
                \includegraphics[width=0.5\textwidth]{images/voronoi2.png}
            \end{subfigure} &
            \begin{subfigure}{0.5\linewidth}
                \centering
                \includegraphics[width=0.5\textwidth]{images/voronoi3.png}
            \end{subfigure}
        \end{tabular}
    \end{figure}

    \begin{itemize}
        \item Vor($P$) can be computed in $\Omega(n\log n)/O(n \log n)$ time using Fortune's algorithm using $O(n)$ storage, using a plane sweep algorithm that uses a horozontal line and craetes a beach line / wavefront. We use the idea of parabolas, focus, and directrix. 
        % \begin{figure}[h]
        %     \centering
        %     \includegraphics[width=0.3\textwidth]{images/voronoi4.png}
        % \end{figure}

        \begin{figure}[h]
            \begin{tabular}{cc}
                \begin{subfigure}{0.5\linewidth}
                    \centering
                    \includegraphics[width=0.5\textwidth]{images/voronoi4.png}
                \end{subfigure} &
                \begin{subfigure}{0.5\linewidth}
                    \centering
                    \includegraphics[width=0.5\textwidth]{images/voronoi5.png}
                \end{subfigure}
            \end{tabular}
        \end{figure}
        \pagebreak
        
        \item Naive algorithm would be to find one voronoi region at a time: 1) Find the half plane for each point using the perpendicular bisector, 2) it is $O(n\log n)$ time for each half plane. Total time for all regions is $O(n^2 \log n)$. 
        \item Given a Voronoi map, we can take the convex hull of the map. All points of the map that are on the hull are part of an infinite voronoi region (i.e. unbounded). So bounded regions are for points inside the hull. 
            \begin{itemize}
                \item D\&C method of finding VD with CH:
                \item Suppose the L and R VD are done and the points are presorted. We do the D\&C CH algo ($O(n \log n)$) and the D\&C VD algo at the same time. 
                \item The time to stitch the two VD together is $O(n)$.
                \item $T(n) = 2 T(\frac{n}{2}) + O(n) = O(n\log n)$
            \end{itemize}

        \item Empty Circle property: at a voronoi vertex, there should be no other voronoi site inside the circle given by the vertex (i.e. the circumcenter). All the Voronoi sites on the circumference of the circle are equidistance from this center. For general position, we say that no more than 3 points are circumcircular to this center.
        \begin{figure}[h]
            \begin{tabular}{cc}
                \begin{subfigure}{0.5\linewidth}
                    \centering
                    \includegraphics[width=0.5\textwidth]{images/voronoi6.png}
                \end{subfigure} &
                \begin{subfigure}{0.5\linewidth}
                    \centering
                    \includegraphics[width=0.5\textwidth]{images/voronoi7.png}
                \end{subfigure}
            \end{tabular}
        \end{figure}



    \end{itemize}


    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%


    \section{Delauney Triangulation}%%%%%%%%%%%%%%%%%%%%%%%
    \label{sec:delauney}
    
        \begin{itemize}
            \item The $\mathcal{DT}(P)$ is the dual of the $\mathcal{VD}(P)$. In a DT, two voronoi sites are connected by an arc iff their two regions are bounded by a common voronoi edge. 
            \item Each triange of the DT is made from the 3 points of each VD's circmcenter.
            \begin{figure}[h]
                \begin{tabular}{cc}
                    \begin{subfigure}{0.5\linewidth}
                        \centering
                        \includegraphics[width=0.5\textwidth]{images/dt1.png}
                    \end{subfigure} &
                    \begin{subfigure}{0.5\linewidth}
                        \centering
                        \includegraphics[width=0.5\textwidth]{images/dt2.png}
                    \end{subfigure}
                \end{tabular}
            \end{figure}

            \item the $\mathcal{DT}(P)$ is can be computed in $O(n\log n)$ time with $O(n)$ storage.
            \item Two edges of the DT intersect in their interiors. 
            \item For all triangles of a DT, the circumcircle for the triangle must be empty in its interior. That is, no voronoi sites will lie inside the circumcircle for the triangle.
            \item If we translate the edges of the 3D convex hull into 2D, we are given the DT of $P$ in 2D.

        \end{itemize}

    %%%%%%%%%%%%%%%%%%%%%%%


    \section{3D Convex Hull}%%%%%%%%%%%%%%%%%%%%%%%
    \label{sec:3dconvexhull}

    \begin{itemize}
        \item the complexity of a 3D CH of $n$ points is $O(n)$.
        \item It can be computed in $O(n \log n)$ time.
        \item Preparata \& Hong, D\&C Algo. for 3D CH: 
            \begin{itemize}
                \item Given a set $S$ if $n$ points in $\mathbb{R}^3$, presort them with respects to $x_1$-axis, and $P$ is the presorted set. Do \textsf{ConvexHull$(P, n)$}:
                \item If $n < 7$, compute the $\mathcal{CH}(P)$ by brute force.  
                \item Else: 
                    \begin{itemize}
                        \item Divide: $k = \floor*{\frac{n}{2}}$, $P_L = {p_1, ..., p_k}$, $P_R = {p_{k+1}, ..., p_n}$
                        \item Recurse: \textsf{ConvexHull$(P_L, k)$}, \textsf{ConvexHull$(P_R, n-k)$}
                        \item Merge: $\mathcal{CH}(P) = $ \textsf{Merge$(\mathcal{CH}(P_L), \mathcal{CH}(P_R))$}
                    \end{itemize}
                \item The whole merge (i.e. finding the sleeve) takes $O(n)$ time. Recurrence is $T(n) = 2 T(\frac{n}{2}) + O(n) = O(n\log n)$
            \end{itemize}
        \item 
    \end{itemize}


    \begin{figure}[h]
        \centering
        \includegraphics[width=0.3\textwidth]{images/3d1.png}
    \end{figure}

    \begin{figure}[h]
        \centering
        \includegraphics[width=0.5\textwidth]{images/3d2.png}
    \end{figure}

    \begin{figure}[h]
        \centering
        \includegraphics[width=0.7\textwidth]{images/3d3.png}
    \end{figure}



    %%%%%%%%%%%%%%%%%%%%%%%



    \section{Linear Programming}%%%%%%%%%%%%%%%%%%%%%%%
    \label{sec:linearprog}

    %%%%%%%%%%%%%%%%%%%%%%%


    \section{Range Search}%%%%%%%%%%%%%%%%%%%%%%%
    \label{sec:range}

        \subsection{1D Range Search} %%%%
            \begin{itemize}
                \item Problem: Given a set $S \subset \mathbb{R}$ of $n$ points and a query interval $I = [\ell, h]$, find $S\cap I = \{x\in S ~|~ \ell \leq x \leq h\}$.
                \item DS: 1D Range Tree - Balanced Binary Search Tree that also has all the elements stored in the in the leaves, and the leaves are connected like a linked list. 
                \item Algorithm: Search the tree for the leaf closes to $\ell$ and report the leaves to the right up to and including $h$.
                \item $P(n\log n)$
                \item $Q(\log n + A)$, $A$ is size of solution set 
                \item $S(n)$
            \end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%%%

        \subsection{2D Range Search} %%%%
            \begin{itemize}
                \item Problem: Given a set $S \subset \mathbb{R}^2$ of $n$ points and a query rectangle $R = [\ell_1, h_1] \times [\ell_2, h_2]$, find $S\cap R - \{ (x,y) \in S ~|~ \ell_1 \leq x \leq \ell_2, h_1 \leq y \leq h_2\}$.
                \item Naive: Use a 1D range tree for the x-coord and a 1D range tree for the y-coord. Find points on the vertical range and horizontal range, and take the intersection of the two as the solution. 
                    \begin{itemize}
                        \item $P(n\log n)$
                        \item $Q(\log n + |S_1| +|S_2|)$
                        \item $S(n)$
                    \end{itemize}

                \item Wasteful: For all possible $\binom{n+1}{2}$ possible vertical strip, make a 1D range tree for the points in that strip; do the 1D query rectangle on the widest strip. 
                    \begin{itemize}
                        \item $P(n^3)$
                        \item $Q(\log n + A)$
                        \item $S(n^3)$
                    \end{itemize}
                
                \item Better: Let $T$ be the BBST for $S$ ordered by the $x_1$-coord. Each node $v \in T$, $v$ has a range tree (the associated structure) for $S_v$ ($S_v \subset S$, $S_v$ is the canonical subset of node $v$) ordered by the $x_2$-coord. I.E. At node $v$, you will get points of a particular $x_1$-range. That node contains a 1D range tree of those points but ordered by their $x_2$-coord.
                    \begin{itemize}
                        \item $P(n\log n)$
                        \item $Q(\log^2 n + A)$
                        \item $S(n\log n )$
                    \end{itemize}

            \end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%%%

        \subsection{d-Dimension Range Search} %%%%
        Similar to the 2D range search problems: Given a set $S \subset \mathbb{R}^d$ of $n$ points and a query rectangle $R = \ell_1 \times \ell_2 \times ... \times \ell_d$, find $S\cap R$. We use a BBST on the $x_1$-coord. $\forall v \in T$, we make an associated secondary $(d-1)$ range tree on the $[x_2, ..., x_d]$ coord.
            \begin{itemize}
                \item $P(n\log^{d-1} n)$
                \item $Q(\log^d n + A)$
                \item $S(n\log^{d-1} n )$
            \end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%%%


    %%%%%%%%%%%%%%%%%%%%%%%


    \section{Geometric Data Structures}%%%%%%%%%%%%%%%%%%%%%%%
    \label{sec:geods}

        \subsection{Interval Tree} %%%%
            \begin{itemize}
                \item Problem: Given a set $S$ of $n$ interval segments, and a query point $q_x$, determine the segments $i\in S$ that contain $q_x$, i.e. report all segments $i \in S$ that intersect the vertical $x = q_x$.
                \item Algorithm: Using the endpoints of the segments in $S$, so there are $2n$ endpoints. Find the median value $m$, and partition $S$ into subsets $S_L$, $S_C$, and $S_R$. $S_L$ and $S_R$ contain segments exclusively to the left or right of the median. $S_C$ contain those segments that are cut by the median. The node for $m$ will contain: one sorted list for the left endpoints of $S_C$, one sorted list for the right endpoints of $S_C$, and its children (left and right subtrees) are recursively defined by $S_L$ and $S_R$. To answer the query, use the median stored at each node as the key. At each node, search the list for segments that contain the target, using the information about the endpoints to know when you have finished traversing down the tree. 
            
                \begin{itemize}
                    \item $P(n\log n)$
                    \item Median finding is $O(n)$
                    \item $Q(\log n + A)$
                    \item $S(n)$
                \end{itemize}
            
            \end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%%%


        \subsection{1D Segment Tree} %%%%
            \begin{itemize}
                \item Given a set $S$ of $n$ interval segments, and a query point $q_x \in \mathbb{R}$, determine the segments $s\in S$ that contain $q_x$, i.e. report all segments $\{s \in S ~|~ q_x \in s\}$ that intersect the vertical $x = q_x$.
                \item The $n$ segments have $2n$ endpoints that break the number line into $2n + 1$ atomic intervals. Build a binary tree such that the leaves are atomic intervals. Label each node $v$ by a subset $T$ of $S$ such that: $s$ is in $T$ if it contains the entire interval of $v$, and $s$ does not contain the enitre of its sibling $v'$. A segment can be associated with at most two nodes per level.  
            
                \begin{itemize}
                    \item $P(n\log n)$
                    \item $Q(\log n + A)$
                    \item $S(n\log n)$, $n$ segments appear in $O(\log n)$ nodes. 
                \end{itemize}
            
            \end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%%%


        \subsection{2D Segment Tree} %%%%
            \begin{itemize}
                \item It is a 1D segment tree on the $x$ intervals, and each node on the tree has a segment tree on the $y$ intervals hanging off of it. For query $(x,y)$, locate $x$ on the primary tree, and $y$ on the secondary tree. Report the rectangles encountered on the path on the secondary tree 
            
                \begin{itemize}
                    \item $P(n\log^2 n)$
                    \item $Q(\log^2 n + A)$
                    \item $S(n\log^2 n)$
                \end{itemize}
            
            \end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%%%

        \subsection{Priority Search Trees: Treaps} %%%%
            \begin{itemize}
                \item Solves 2D range queries when the queries are unbounded rectangles. Ex: $[x_0, x_1] \times [y_0, \infty]$
                \item Find a point of $y$-max-coord $p \in S$ and remove it from the set. Let that be the root of the current tree. 
                \item Find the median point $m$ of x-coords. of the remaining points. 
                \item Divide $S$ into $S_L$ and $S_R$. 
                \item Create the vertex/node $v$ for $p$ and $m$. Let its children be treaps for $S_L$ and $S_R$.
                \item Query: 
                \item locate the two leaves that follow $x_0$ and precedes $x_1$. For each node on the path, check if the node's $p$ is in the query range. Search all subtrees between the two paths. Report all points with y-coord at least $y_0$. By the heap property, we can stop searching a path when we hit a point with a $y$-coord less than $y_0$. 
            
                \begin{itemize}
                    \item $P(n\log n)$
                    \item $Q(\log n + A)$
                    \item $S(n)$
                \end{itemize}
            
            \end{itemize}

        %%%%%%%%%%%%%%%%%%%%%%%%%%


    %%%%%%%%%%%%%%%%%%%%%%%


    \section{Rectilinear Computaion Geometry}%%%%%%%%%%%%%%%%%%%%%%%
    \label{sec:linearprog}

    \begin{center}
        \begin{tabular}{lll p{5cm}}
            Algo. & Time & Space & Notes \\ 
            \hline 
            Lipski-Preparata (PS) & $O(n\log n + p \log \frac{n^2}{p})$ & $O(n + p)$ & Determine vertical edges. Order left-right. \\
            Wood (PS) & $O(n\log n + p)$ & $O(n + p)$ & Determine horizontal edges. Order left-right.\\ 
            Guting (D\&C) & $O(n\log n + p)$ & $O(n\log n + p)$ & Determine horizontal edges. Order left-right.
        \end{tabular}
    \end{center}

    $p$ is the output size.

    %%%%%%%%%%%%%%%%%%%%%%%
    
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   


    \pagebreak
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \begin{thebibliography}{1}
        \bibitem[1]{berg08}Mark de Berg, Otfried Cheong, Marc van Kreveld, and Mark Overmars. 2008. Computational Geometry: Algorithms and Applications (3rd ed. ed.). Springer-Verlag TELOS, Santa Clara, CA, USA.
        \bibitem[2]{kirk1986}David G Kirkpatrick and Raimund Seidel. 1986. \href{http://graphics.stanford.edu/courses/cs268-16-fall/Notes/KirkSeidel.pdf}{The ultimate planar convex hull algorithm}. SIAM J. Comput. 15, 1 (Feb. 1986), 287-299. https://doi.org/10.1137/0215021
        \bibitem[3]{kirk1983}David G Kirkpatrick. 1983. \href{https://www.ics.uci.edu/~goodrich/teach/geom/notes/Kirkpatrick-paper.pdf}{Optimal Search in Planar Subdivisions}. SIAM J. Comput. 12, 1 (Feb. 1983), 28-35.
    \end{thebibliography}
    % END %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}